## misc functions
null2na <- function (x) 
{
  if (is.null(x) || length(x) == 0) 
    x <- as.character(NA)
  else x <- unique(unlist(x))
  x
}

genBPGraph <- function(bpMat, directed=TRUE, bp=TRUE){

  bpMat1 <- bpMat
  b <- rownames(bpMat)
  p <- colnames(bpMat)
 
  if(!bp){
    if(sum(b != p) != 0){
      stop("The rownames and the colnames must be identical.")
    }
  } else{
    baits <- union(rownames(bpMat), colnames(bpMat))
    preys <- baits

    bpMat1 <- matrix(0, length(baits), length(preys))
    dimnames(bpMat1) <- list(baits, preys)
   
    bpMat1[b,p] <- bpMat
    if(!directed) {
      bpMat1 <- bpMat1 + t(bpMat1)
      mode(bpMat1) <- "logical"
      mode(bpMat1) <- "numeric"
    }
  }

  if(directed){
    bpGraph <- as(bpMat1, "graphNEL")
  }

  else{
    bpGraph <- as(bpMat1, "graphNEL")
    bpGraph <- ugraph(removeSelfLoops(bpGraph))
  }
  
  bpGraph
  
}

statusDisplay <- function(...) {
  cat(...)
}
statusIndicator <- function(x, length, N=40) {
  stages <- round(length/N + 0.5)
  if (x > length) {warning("Indicator received wrong message!\n"); x <- length}
  if (x %% stages == 0 | x == length) {
    per <- round(x/length,2)
    statusDisplay("\r  ",per*100, "% ", rep("=",round(N*per)), ">",sep="")
  }
}

####################################################
## PSI-MI 2.5 XML entry parsers
## Low-level parsers, only accessible for developers
####################################################

## experiment parser
.parsePsimi25Experiment <- function(root, namespaces, sourceDb) {
  subDoc <- xmlDoc(root)
  
  interactionType <- unlist(xpathApply(doc = subDoc,
                                       path = "/ns:experimentDescription/ns:interactionDetectionMethod/ns:names/ns:shortLabel",
                                       fun = xmlValue,
                                       namespaces = namespaces)
                            )
  if(length(interactionType) == 0 && is.null(interactionType)) {
    interactionType <- unlist(xpathApply(doc = subDoc,
                                         path = "/ns:experimentDescription/ns:interactionDetectionMethod/ns:names/ns:fullName",
                                         fun = xmlValue,
                                         namespaces = namespaces)
                            )
  }
  
  ## it seems that xpathApply treats XPath in a case-insensitive way, to be confirmed
  expPubMed <- unlist(xpathApply(doc = subDoc,
                                 path = "/ns:experimentDescription/ns:bibref/ns:xref/ns:primaryRef[@db='pubmed']", 
                                 fun = xmlGetAttr,
                                 name = "id",
                                 namespaces = namespaces)
                      )

  ## experiment source Id
  expSourceId <- unlist(xpathApply(doc = subDoc,
                                   path = paste("/ns:experimentDescription/ns:xref/ns:primaryRef[@db='",sourceDb,"']",sep=""),
                                   fun=xmlGetAttr,
                                   name="id", namespaces=namespaces))

  ### if expSourceId not found, try alternatives
  if(is.null(expSourceId)) {
    expSourceId <- unlist(xpathApply(doc = subDoc,
                                     path = paste("ns:experimentList/ns:experimentDescription/ns:xref/ns:secondaryRef[@db='",
                                       sourceDb,
                                       "']|/ns:experimentDescription",sep=""), 
                                     fun = xmlGetAttr,
                                     name = "id", namespaces = namespaces)
                          )
  }

  free(subDoc)
  experiment <- new("psimi25Experiment",
                    sourceDb = null2na(sourceDb),
                    interactionType = null2na(interactionType),
                    expSourceId = null2na(expSourceId),
                    expPubMed = null2na(expPubMed)
                    )
  return(experiment)
}


## interactor parse
.parsePsimi25Interactor <- function(root, namespaces, sourceDb, uniprotsymbol) {
  subDoc <- xmlDoc(root)
  sourceIds <- unlist(xpathApply(doc = subDoc, path = "/ns:interactor", 
                                 fun = xmlGetAttr, name = "id", namespaces = namespaces))
  shortLabels <- unlist(xpathApply(doc = subDoc,
                                   path="/ns:interactor/ns:names/ns:shortLabel",
                                   fun = xmlValue,
                                   namespaces = namespaces))
  if(length(shortLabels) == 0 && is.null(shortLabels)) {
    shortLabels <- unlist(xpathApply(doc = subDoc,
                                     path="/ns:interactor/ns:names/ns:fullName",
                                     fun = xmlValue,
                                     namespaces = namespaces))
  }
  shortLabels <- null2na(shortLabels)
  
  organismNames <- null2na(unlist(xpathApply(doc = subDoc, path = "/ns:interactor/ns:organism/ns:names/ns:fullName", 
                                             fun = xmlValue, namespaces = namespaces)))
  taxIds <- unlist(null2na(xpathApply(doc = subDoc, path = "/ns:interactor/ns:organism", 
                              fun = xmlGetAttr, name = "ncbiTaxId", namespaces = namespaces)))
  
  uniprot <- unlist(null2na(xpathApply(doc = subDoc,
                                       path = sprintf("/ns:interactor/ns:xref/ns:primaryRef[@db='%s']|/ns:interactor/ns:xref/ns:secondaryRef[@db='%s']",uniprotsymbol, uniprotsymbol),
                                       fun = xmlGetAttr,
                                       name = "id",
                                       namespaces=namespaces)))[1]
  xrefDb <- unlist(xpathApply(doc = subDoc,
                              path = "/ns:interactor/ns:xref/ns:primaryRef|/ns:interactor/ns:xref/ns:secondaryRef",
                              fun = xmlGetAttr,
                              name = "db",
                              namespaces = namespaces))
  xrefId <- unlist(xpathApply(doc = subDoc,
                              path = "/ns:interactor/ns:xref/ns:primaryRef|/ns:interactor/ns:xref/ns:secondaryRef",
                              fun = xmlGetAttr,
                              name = "id",
                              namespaces = namespaces))
  
  sourceIdMat <- cbind("sourceId", sourceIds)
  tempMat <- matrix(c(xrefDb, xrefId), ncol=2, byrow=FALSE)
  xrefMat <- rbind(sourceIdMat, tempMat)
  colnames(xrefMat) <- c("db","id")
  xrefEnv <- new.env()
  xref <- assign("xref",xrefMat, envir=xrefEnv) 
                     
  free(subDoc)
  interactor <- new("psimi25Interactor",
                    sourceDb = sourceDb,
                    sourceId = sourceIds,
                    shortLabel = shortLabels,
                    uniprotId = uniprot,
                    organismName = organismNames,
                    taxId = taxIds,
                    xref = xrefEnv
                    )
  return(interactor)
}


## complex parser
.parsePsimi25Complex <- function(root, namespaces, sourceDb) {
	subDoc <- xmlDoc(root)
	# source ID
	sourceId <- as.character(xpathApply(doc=subDoc,
				path=paste("/ns:interaction/ns:xref/ns:primaryRef[@db='",sourceDb,"']",sep=""),
				fun=xmlGetAttr,
				name="id",
				namespaces=namespaces))
	# short label
	shortLabel <- as.character(xpathApply(doc=subDoc,
				path="/ns:interaction/ns:names/ns:shortLabel",
				fun=xmlValue,
				namespaces=namespaces))
	# full name
	fullName <-as.character(xpathApply(doc=subDoc,
                                path="/ns:interaction/ns:names/ns:fullName",
                                fun=xmlValue,
                                namespaces=namespaces))
 
	# interactors
	interactorIds <-as.character(xpathApply(doc=subDoc,
                                path="/ns:interaction/ns:participantList/ns:participant/ns:interactorRef",
                                fun=xmlValue,
                                namespaces=namespaces))

	# attributes
	attributeNodes <- getNodeSet(subDoc, 
				"/ns:interaction/ns:attributeList/ns:attribute[@name]",
				namespaces=namespaces)
	if (length(attributeNodes)>0) {
		attributeNames <- sapply(attributeNodes, xmlGetAttr, name="name")
		attributes <- sapply(attributeNodes, xmlValue)
		names(attributes) <- attributeNames
	} else {
		attributes <- character(0)
	}
	free(subDoc)
	
	list(sourceDb = sourceDb,
             sourceId = sourceId,
             shortLabel= shortLabel,
             fullName=fullName,
             interactorIds=interactorIds,
             attributes=attributes)
}

##############################################
## High-level parsers taking files as input
##############################################

## File parser: parsing file into interaction entries
parsePsimi25Interaction <- function (psimi25file, psimi25source, verbose=TRUE) {
  psimi25Doc <- xmlTreeParse(psimi25file, useInternalNodes = TRUE)
                           
  psimi25NS <- getDefaultNamespace(psimi25Doc)
  namespaces <- c(ns = psimi25NS)
  entry <- getNodeSet(psimi25Doc, "/ns:entrySet/ns:entry", namespaces)
  entryCount <- length(entry)

  getValueWithPath <- function(doc, path, ns) {
    x <- unlist(xpathApply(doc=doc,path=path,fun=xmlValue, namespaces=ns))
    return(null2na(x))
  }

  getMapping <- function(x, matrix, nameCol, valueCol) {
    names <- matrix[,nameCol]
    ind <- match(x, names)
    if (length(ind) == 1 && is.na(ind)) {
      value <- as.character(NA)
    } else {
      value <- unlist(matrix[ind, valueCol])
    }
    return(value)
  }
  
  ## get interaction details from interaction node
  getInteraction <- function(theNodes, index,  sourcedb, expEnv, interactorInfo, namespaces) {
    interactions <- vector("list",length=length(theNodes))
    if (verbose)
      statusDisplay("  Parsing interactions:\n")
    for (i in seq(along=theNodes)) {
      if (verbose) {
        statusIndicator(i, length(theNodes))
      }
      theNode <- theNodes[[i]]
      subDoc <- xmlDoc(theNode)
      psimi25Ids <- xpathApply(doc = subDoc,
                               path = paste("/ns:interaction/ns:xref/ns:primaryRef[@db='",
                                sourcedb,"']",sep=""), 
                               fun = xmlGetAttr, name = "id", namespaces = namespaces)
      psimi25Id <- null2na(unlist(psimi25Ids)[[1]])
      
      expRef <- unlist(xpathApply(doc = subDoc,
                                  path = "/ns:interaction/ns:experimentList/ns:experimentRef",
                                  fun = xmlValue, namespaces = namespaces))

      if ((!is.null(expRef)) && exists(expRef, envir = expEnv)) {
        expData <- get(expRef, envir = expEnv)
        interactionType <- expData@interactionType
        expPsimi25 <- expData@expSourceId
        expPubMed <- expData@expPubMed
      }
      else {
        interactionType <- null2na(unlist(xpathApply(doc = subDoc,
                                             path = "/ns:interaction/ns:experimentList/ns:experimentDescription/ns:interactionDetectionMethod/ns:names/ns:shortLabel",
                                             fun = xmlValue,
                                             namespaces = namespaces))[[1]])
        if(length(interactionType) == 1 && is.na(interactionType)) {
          interactionType <- null2na(unlist(xpathApply(doc = subDoc,
                                                       path = "/ns:interaction/ns:experimentList/ns:experimentDescription/ns:interactionDetectionMethod/ns:names/ns:fullName",
                                                       fun = xmlValue,
                                                       namespaces = namespaces))[[1]]) 
        }
        expPsimi25 <- null2na(unlist(xpathApply(doc = subDoc,
                                             path = sprintf("/ns:interaction/ns:experimentList/ns:experimentDescription/ns:xref/ns:primaryRef[@db='%s']",sourcedb),
                                             fun = xmlGetAttr,
                                             name = "id",
                                             namespaces = namespaces))[[1]])
        expPubMed <- null2na(unlist(xpathApply(doc = subDoc,
                                             path = "/ns:interaction/ns:experimentList/ns:experimentDescription/ns:bibref/ns:xref/ns:primaryRef[@db='pubmed']",
                                             fun = xmlGetAttr,
                                             name = "id",
                                             namespaces = namespaces))[[1]])
      }
      ### misc attributes
      ## confidence value
      rolePath <-  "/ns:interaction/ns:confidenceList/ns:confidence/ns:value"
      confidenceValue <- getValueWithPath(doc=subDoc,path = rolePath, ns = namespaces)

      ## participant
      rolePath <- "/ns:interaction/ns:participantList/ns:participant/ns:interactorRef"
      participantRefs <- getValueWithPath(doc=subDoc, path=rolePath, ns = namespaces)
      if(length(participantRefs) == 1 && is.na(participantRefs)) {
        rolePath <- "/ns:interaction/ns:participantList/ns:participant/ns:interactor"
        participantRefs <- null2na(xpathApply(doc=subDoc,
                                      path=rolePath,
                                      fun=xmlGetAttr,
                                      name="id", namespaces=namespaces))
      }
      
      ## bait
      rolePath <- "/ns:interaction/ns:participantList/ns:participant[ns:experimentalRoleList/ns:experimentalRole/ns:names/ns:fullName='bait']/ns:interactorRef"
      baitRefs <- getValueWithPath(doc=subDoc, path = rolePath, ns = namespaces)
      if(length(baitRefs)==1 && is.na(baitRefs)) {
         rolePath <- "/ns:interaction/ns:participantList/ns:participant[ns:experimentalRoleList/ns:experimentalRole/ns:names/ns:fullName='bait']/ns:interactor"
         baitRefs <- null2na(xpathApply(doc=subDoc,
                                      path=rolePath,
                                      fun=xmlGetAttr,
                                      name="id", namespaces=namespaces))
      }
      
      ##prey
      rolePath <- "/ns:interaction/ns:participantList/ns:participant[ns:experimentalRoleList/ns:experimentalRole/ns:names/ns:fullName='prey']/ns:interactorRef"
      preyRefs <- getValueWithPath(doc=subDoc, path = rolePath, ns = namespaces)
      if(length(preyRefs) == 1 && is.na(preyRefs)) {
        rolePath <- "/ns:interaction/ns:participantList/ns:participant[ns:experimentalRoleList/ns:experimentalRole/ns:names/ns:fullName='prey']/ns:interactor"
        preyRefs <- null2na(xpathApply(doc=subDoc,
                                      path=rolePath,
                                      fun=xmlGetAttr,
                                      name="id", namespaces=namespaces))
      }
      
      ## inhibitor
      rolePath <- "/ns:interaction/ns:participantList/ns:participant[ns:experimentalRoleList/ns:experimentalRole/ns:names/ns:fullName='inhibitor']/ns:interactorRef"
      inhibitorRefs <- getValueWithPath(doc=subDoc, path=rolePath, ns = namespaces)

      ## neutral component
      rolePath <- "/ns:interaction/ns:participantList/ns:participant[ns:experimentalRoleList/ns:experimentalRole/ns:names/ns:fullName='neutral component']/ns:interactorRef"
      neutralComponentRefs <- getValueWithPath(doc=subDoc, path = rolePath, ns = namespaces)
      
      free(subDoc)
      
 
      srcLabel <- "sourceId"; uniLabel <- "uniprotId"
      participantUniprot <- getMapping(participantRefs, interactorInfo, srcLabel, uniLabel)
      preyUniprot <- getMapping(preyRefs, interactorInfo, srcLabel, uniLabel)
      baitUniprot <- getMapping(baitRefs, interactorInfo, srcLabel, uniLabel)
      inhibitorUniprot <- getMapping(inhibitorRefs,  interactorInfo, srcLabel, uniLabel)
      neutralComponentUniprot <- getMapping(neutralComponentRefs,  interactorInfo, srcLabel, uniLabel)

      interactions[[i]] <- new("psimi25Interaction",
                               sourceDb = sourcedb,
                               sourceId = as.character(psimi25Id), ## FIXME: can we do it nullable?
                               interactionType = interactionType, 
                               expPubMed = expPubMed,
                               expSourceId = expPsimi25, 
                               confidenceValue = confidenceValue,
                               participant = participantUniprot,
                               bait = baitRefs,
                               baitUniProt = baitUniprot, 
                               prey = preyRefs,
                               preyUniProt = preyUniprot,
                               inhibitor = inhibitorUniprot, 
                               neutralComponent = neutralComponentUniprot
                               )
    }
    if(verbose) {
      statusDisplay("\n")
    }
    interactions
  }

  if(verbose)
    statusDisplay(paste(length(entryCount),"Entries found\n",sep=" "))
  entryList <- lapply(seq(entryCount), function(i) {
    if(verbose)
      statusDisplay(paste("Parsing entry",i,"\n",sep=" "))
    basePath <- paste("/ns:entrySet/ns:entry[", i, "]", sep = "", 
                      collapse = "")
    thisEntry <- new("psimi25InteractionEntry")

    ## experiment
    experimentPath <- paste(basePath, "/ns:experimentList/ns:experimentDescription", 
                            sep = "", collapse = "")
    experimentNodes <- getNodeSet(psimi25Doc, experimentPath, 
                                  namespaces)

    experimentEnv <- new.env(parent = emptyenv(), hash = TRUE)
    if(verbose)
      statusDisplay("  Parsing experiments: ")
    lapply(experimentNodes, function(thisExperiment) {
      experimentId <- xmlGetAttr(thisExperiment, name = "id")
      experimentData <- parseExperiment(psimi25source, thisExperiment,namespaces)
      assign(experimentId, experimentData, envir = experimentEnv)
      if(verbose)
        statusDisplay(".")
      ""
    })
    if(verbose)
      statusDisplay("\n")
    
    releaseDatePath <- paste(basePath, "/ns:source", sep = "", 
                             collapse = "")
    releaseDate <- xpathApply(doc = psimi25Doc, path = releaseDatePath, 
                              fun = xmlGetAttr, name = "releaseDate", namespaces = namespaces)
    thisEntry@releaseDate <- null2na(unlist(releaseDate))

    ## interactor
    interactorPath <- paste(basePath, "/ns:interactorList/ns:interactor", 
                            sep = "", collapse = "")
    interactorNodes <- getNodeSet(psimi25Doc, interactorPath, 
                                  namespaces)
    if(length(interactorNodes) == 0) { ## in case no interactorList was provided
      interactorPath <- paste(basePath, "/ns:interactionList/ns:interaction/ns:participantList/ns:participant/ns:interactor",
                              sep="", collapse="")
      interactorNodes <- getNodeSet(psimi25Doc, interactorPath, 
                                    namespaces)
    }
    interactorIds <- sapply(interactorNodes, xmlGetAttr, 
                            name = "id")
    interactorCount <- length(interactorNodes)
    interactors <- vector("list",length=interactorCount)
    if(verbose)
      statusDisplay("  Parsing interactors:\n")
    if (interactorCount > 0) {
      for (p in seq(interactorCount)) {
        if(verbose)
          statusIndicator(p, interactorCount)
        theRes <- parseInteractor(psimi25source, interactorNodes[[p]], namespaces)
        interactors[[p]] <- theRes
      }
    }
    if(verbose)
      statusDisplay("\n")
    interactorInfMat <- interactorInfo(interactors)
    names(interactors) <- interactorInfMat[,"uniprotId"]
    
    organismName <- unique(unlist(interactorInfMat[, "organismName"]))
    thisEntry@organismName <- organismName
    taxId <- unique(unlist(interactorInfMat[, "taxId"]))
    thisEntry@taxId <- taxId
    interactionPath <- paste(basePath, "/ns:interactionList/ns:interaction", 
                             sep = "", collapse = "")
    interactionNodes <- getNodeSet(psimi25Doc, interactionPath, 
                                   namespaces = namespaces)
    sourcedb <- sourceDb(psimi25source)

    interactions <- getInteraction(interactionNodes,
                                   sourcedb = sourcedb, expEnv = experimentEnv,
                                   interactorInfo = interactorInfMat,
                                   namespaces=namespaces)
    
    thisEntry@interactions <- interactions
    rownames(interactorInfMat) <- interactorInfMat[, "uniprotId"]
    thisEntry@interactors <- interactors
    thisEntry
  })
  
  free(psimi25Doc)
  if (length(entryList) > 1) {
    el <- new("psimi25InteractionEntry")
    organismName(el) <- unique(unlist(sapply(entryList, organismName, simplify=FALSE)))
    taxId(el) <-  unique(unlist(sapply(entryList, taxId, simplify=FALSE)))
    releaseDate(el) <- unique(unlist(sapply(entryList, releaseDate,simplify=FALSE)))
    interactors(el) <- unique(unlist(sapply(entryList, interactors)))
    interactions(el) <- unique(unlist(sapply(entryList, interactions)))
    return(el)
  } else {
    return(entryList[[1]])
  }
}


## File parser: parsing file into complex
parsePsimi25Complex <- function(psimi25file, psimi25source, verbose=FALSE) {
  psiDoc <- xmlTreeParse(psimi25file, useInternalNodes=TRUE)
  psiNS <- xmlNamespaceDefinitions(psiDoc)
  namespaces <- c(ns=psiNS[[1]]$uri)

  releaseDate <- null2na(xpathApply(doc=psiDoc,
                            path="//ns:entry/ns:source", 
                            fun=xmlGetAttr,
                            name="releaseDate", 
                            namespaces=namespaces)[[1]])
  ##############
  # interactor #
  ##############
  interactorNodes <- getNodeSet(psiDoc,
                                "//ns:interactorList/ns:interactor", namespaces)
  interactorIds <- sapply(interactorNodes, xmlGetAttr, name="id")
  interactorCount <- length(interactorNodes)
  interactors <- vector("list", length=interactorCount)
  if(verbose)
    statusDisplay("  Parsing interactors:\n")
  for (i in seq(interactorCount)) {
    if(verbose)
      statusIndicator(i, interactorCount)
    theRes <- parseInteractor(psimi25source, interactorNodes[[i]], namespaces)
    interactors[[i]] <- theRes
  }
  if(verbose)
    statusDisplay("\n")
  
  interactorInfo <- interactorInfo(interactors)
  names(interactors) <- interactorInfo[,"uniprotId"]
  ##############
  # complex    #
  ##############
  complexNodes <- getNodeSet(psiDoc, "//ns:interactionList/ns:interaction", namespaces)
  if (verbose)
    statusDisplay("  Parsing complexes:\n")
  complexList <- lapply(complexNodes, function(thisNode) {
    thisComplex <- parseComplex(psimi25source, thisNode, namespaces)
    participantRef <- split(thisComplex$interactorIds, 
                            as.factor(thisComplex$interactorIds))
    multiplicity <- sapply(participantRef, length)
    if ( !all(names(participantRef) %in% interactorIds) ) {
      msg <- paste("parse complex ", thisComplex$shortLabel, 
                   "can't resolve all interactor references.")
      stop(msg)
    }	
    participantIndex <- interactorIds %in% names(participantRef)
    participants <- interactorInfo[participantIndex, "sourceId"];
    participantsUniProt <- interactorInfo[participantIndex, "uniprotId"];
    names(participants) <- as.character(participants)
    participants <- data.frame(sourceId=participants, uniprotId = participantsUniProt, multiplicity=multiplicity)
    thisOrganism <- unique(as.character(interactorInfo[participantIndex,"organismName"]))
    thisTaxid <- unique(as.character(interactorInfo[participantIndex, "taxId"]))

    new("psimi25Complex",
        sourceDb = thisComplex$sourceDb,
        sourceId = thisComplex$sourceId,
        shortLabel=thisComplex$shortLabel,
        fullName=thisComplex$fullName,
        organismName=thisOrganism,
        taxId=thisTaxid,
        members=participants,
        attributes=thisComplex$attributes
        )
  })
  if(verbose)
    statusDisplay("\n")
  free(psiDoc)
  new("psimi25ComplexEntry",
      interactors=interactors,
      complexes=complexList,
      releaseDate=releaseDate)
}

## File parser: parsing file into graph
psimi25XML2Graph <- function(psimi25files,psimi25source,
                             type="interaction",
                             directed=TRUE,...) {
  stopifnot(type %in% c("interaction","complex"))

  if(type == "interaction"){
    result <- lapply(psimi25files, parsePsimi25Interaction, psimi25source,...)
    bpGraph <- interactionEntry2graph(result, directed=directed)
  }
  
  if (type == "complex"){
    result <- lapply(psimi25files, parsePsimi25Complex, psimi25source,...)
    bpGraph <- complexEntry2graph(result)
  }

  return(bpGraph)
}

interactionEntry2graph <- function(interactionEntry, directed=TRUE) {
  if(is(interactionEntry, "psimi25InteractionEntry")) {
    interactionEntry <- list(interactionEntry)
  }
  
  baitList <- lapply(interactionEntry, function(x){
    baits <- sapply(interactions(x), bait)
  })
    
  preyList <- lapply(interactionEntry, function(x){
    prey <- sapply(interactions(x), prey)
  })

  index <- sapply(baitList, class) == sapply(preyList, class)
  
  for(i in 1:length(index)){
    if(!index[i]){
      newBait <- vector(length=length(unlist(preyList[[i]])))
      k <- 1
      for(j in 1:length(preyList[[i]])){
        newBait[k:(k+length(preyList[[i]][[j]])-1)] <- rep(baitList[[i]][j], length(preyList[[i]][[j]]))
        k <- k + length(preyList[[i]][[j]])
      }
      baitList[[i]] <- newBait
    } 
  }
  
  
  b <- unlist(baitList); b[is.na(b)] <- "NA";
  p <- unlist(preyList); p[is.na(p)] <- "NA";
  
  bpList <- split(p,b)
  bpMat <- list2Matrix(bpList)
  
  bpG <- genBPGraph(bpMat, directed = directed)
  
  bpInteractors <- list()
  for(i in seq(interactionEntry)) {
    ints <- interactors(interactionEntry[[i]])
    newInts <- which(!names(ints) %in% bpInteractors)
    bpInteractors <- append(bpInteractors, ints[newInts])
  }
  bpGraph <- as(bpG, "psimi25Graph")
  bpGraph@interactors <- bpInteractors
  
  return(bpGraph)
}

complexEntry2graph <- function(complexEntry) {
  if(!is(complexEntry, "list")) {
    complexEntry <- list(complexEntry)
  }
  listOfListOfComps <- lapply(complexEntry, function(x){
    lapply(x@complexes, function(y){
      p <- as.vector(rep(y@members[,2], y@members[,3]))
      
      attr(p, "complexName") <- y@fullName 
      p
    })
  })
  he <- do.call(c, listOfListOfComps)
  nodes <- unique(unlist(he))
  hEdges <- lapply(he, function(x) {e <- Hyperedge(x, attr(x,"complexName"))})
  
  bpInteractors <- list()
  for(i in seq(complexEntry)) {
    ints <- interactors(complexEntry[[i]])
    newInts <- which(!names(ints) %in% bpInteractors)
    bpInteractors <- append(bpInteractors, ints[newInts])
  }
  
  bpGraph <- new("psimi25Hypergraph",
                 interactors=bpInteractors,
                 nodes=nodes,
                 hyperedges = hEdges)
  return(bpGraph)
}

buildPCHypergraph <- function(xmlFiles, psimi25source, split.by=c("none","organismName","taxId"), ...) {
  split.by <- match.arg(split.by)
  ie <- lapply(xmlFiles, parsePsimi25Complex, psimi25source, ...)
  hg <- complexEntry2graph(ie)

  if(split.by=="none")
    return(hg)
  
  hyperedges <- hyperedges(hg)
  interactors <- interactors(hg)
  hnodes <- nodes(hg)

  inOrgs <- sapply(interactors, organismName)
  inTax <- sapply(interactors, taxId)
  if(split.by == "organismName") {
    sf <- factor(inOrgs)
  } else if (split.by == "taxId") {
    sf <- factor(inTax)
  }

  hyperSf <- sapply(hyperedges, function(x) unique(sf[nodes(x)]))
  sfLevels <- levels(sf)

  hypers <- list()
  for(i in seq(along=sfLevels)) {
    le <- sfLevels[i]
    heOfLevel <- sapply(hyperSf, function(x) any(x %in% le))
    itOfLevel <- sf == le
    nodesOfLevel <- unique(unlist(sapply(hyperedges[heOfLevel],nodes)))
    
    hypers[[i]] <- new("psimi25Hypergraph",
                 interactors = interactors[itOfLevel],
                 nodes = nodesOfLevel,
                 hyperedges = hyperedges[heOfLevel])
                 
  }
  names(hypers) <- sfLevels

  return(hypers)
}

separateXMLDataByExpt <- function(xmlFiles, psimi25source, type = "direct", directed=TRUE, abstract=FALSE,...){
  

  if(!(type %in% c("direct","indirect", "eg"))){
    stop("The argument type needs to be either direct or indirect")
  }

  if(type == "direct"){
    interactionTypeWanted = c("two hybrid","two hybrid array", 
                               "2h fragment pooling", "2 hybrid",
                               "two hybrid pooling")}
  if(type == "indirect"){
    interactionTypeWanted = c("coip","anti tag coip","pull down","tap",
        "anti bait coip","affinity chrom","chromatography","ion exchange chrom"
        ,"affinity techniques")}
  if(type == "eg"){
    interactionTypeWanted = c("spr")}
  
  #create a list of psimi25interaction objects corresponding to the list of xml files
  ie <- lapply(xmlFiles, parsePsimi25Interaction, psimi25source,...)

  
  #create an aggregate interactor list from all psimi25interactio objects
  interactorList <- lapply(ie, function(x) x@interactors)
  combinedList <- do.call(c, interactorList)
  protId <- unique(names(combinedList))
  uniqueCombList <- combinedList[protId]

  psiM <- lapply(ie, function(x){getDesired(x,interactionTypeWanted)})

  #now we have a kx3 matrix that has (bait,prey,pmid) info for all xml files
  psi <- do.call(rbind, psiM)

  if(is.null(psi)) {stop("There are no interactions of the type that you requested
                         within these XML files.")}

  #split the bait/prey info by pmid
  psiBPPairs <- split(data.frame(psi[,c("Bait","Prey")],
    stringsAsFactors=FALSE),psi[,"PMID"])

  #for each pmid, split the prey by the baits (we only want non-empty stuff)
  psiBPList <- lapply(psiBPPairs, function(x){split(x[,2], x[,1])})
  psiBPList <- lapply(psiBPList, function(x) {y = x[listLen(x)>0]; return(y)})

  #from each bpList for each pmid, we create adjMat and graphNEL
  psiBPMatrix <- lapply(psiBPList, list2Matrix)
  psiBPMatrix <- lapply(psiBPMatrix, t)
  psiBPGraphs <- lapply(psiBPMatrix, function(x) {genBPGraph(x, directed=directed)})

  
  
  #get abstract information for each dataset if desired
  if(abstract){
    pmids <- names(psiBPGraphs)
    abst <- getAbstractByPMID(pmids)

  #lastly, we create a psimi25Graph from each of the graphNELs
    psiGraphs <- mapply(function(x,w) {y <- as(x, "psimi25Graph");
                                       y@interactors <- uniqueCombList[nodes(x)];
                                       y@abstract = w; return(y)},
                        psiBPGraphs, abst)
  }

  else{

    psiGraphs <- lapply(psiBPGraphs, function(x,w) {
      y <- as(x, "psimi25Graph"); y@interactors <- uniqueCombList[nodes(x)];
      return(y)})

  }
  #return the graph objects
  return(psiGraphs)

  ###this works for intact, need to test on all other databases!!!
}

getDesired <- function(interactionEntry, intType){

  #options(error=recover)
  x <- interactions(interactionEntry)
  
  dataL <- lapply(x, function(y){
    if(any(y@interactionType %in% intType)) {
      z <- c(bait(y), prey(y), pubmedID(y), interactionType(y));
      
      if(length(z)==4){
        if(!(is.na(z[1])) && !(is.na(z[2]))) {
          return(z)
        } else {
          return(NULL)
        }
      }
      
      if(length(z)>4){
        ## remove NA nodes
        bs <- bait(y); bs <- bs[!is.na(bs)]
        ps <- prey(y); ps <- ps[!is.na(ps)]
        ## if baits are all NAs, the item will be discarded, since later BP pairs will be indexed by bait
        if(all(is.na(bs))) {
          return(NULL)
        }
        
        nrow <- length(bs)*length(ps)
        bpm <- matrix(nrow=nrow, ncol=4)
        
        bpm[,1] <- rep(bs, each=length(ps));
        bpm[,2] <- rep(ps, length(bs))
        bpm[,3] <- rep(pubmedID(y), nrow);
        bpm[,4] <- rep(interactionType(y), nrow);
        return(bpm)}
    }
  }
                  )
  
  dataL <- dataL[!(sapply(dataL, is.null))]
  if(length(dataL)>0){
    dataM <- do.call(rbind, dataL)
    colnames(dataM) <- c("Bait","Prey","PMID", "Interaction Type")
    return(dataM)
  } else {
    return(NULL)
  }
  
}
  
